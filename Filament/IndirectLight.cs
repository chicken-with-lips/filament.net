using System;
using OpenTK.Mathematics;

namespace Filament
{
    /// <summary>
    /// IndirectLight is used to simulate environment lighting, a form of global illumination.
    /// </summary>
    /// <remarks>
    /// <para>Environment lighting has a two components:</para>
    /// <list>
    ///     <item><term>1. irradiance</term></item>
    ///     <item><term>2. reflections (specular component)</term></item>
    /// </list>
    /// <para>Environments are usually captured as high-resolution HDR equirectangular images and processed  by the
    /// cmgen tool to generate the data needed by IndirectLight.</para>
    /// <para>Note: Currently IndirectLight is intended to be used for "distant probes", that is, to represent global
    /// illumination from a distant (i.e. at infinity) environment, such as the sky or distant mountains. Only a single
    /// IndirectLight can be used in a Scene. This limitation will be lifted in the future.</para>
    /// <para>Creation and destruction</para>
    /// ========================
    /// <para>An IndirectLight object is created using the <see cref="IndirectLightBuilder"/> and destroyed by calling
    /// <code>Engine.Destroy()</code>.</para>
    /// <para>Irradiance</para>
    /// ==========
    /// <para>The irradiance represents the light that comes from the environment and shines an object's surface.</para>
    /// <para>The irradiance is calculated automatically from the Reflections (see below), and generally doesn't need to
    /// be provided explicitly.  However, it can be provided separately from the Reflections as
    /// https://en.wikipedia.org/wiki/Spherical_harmonics (SH) of 1, 2 or 3 bands, respectively 1, 4 or 9 coefficients.
    /// </para>
    /// <para>Note: Use the **cmgen** tool to generate the `SH` for a given environment.</para>
    /// <para>Reflections</para>
    /// ===========
    /// <para>The reflections on object surfaces (specular component) is calculated from a specially filtered cubemap
    /// pyramid generated by the **cmgen** tool.</para>
    /// </remarks>
    public class IndirectLight : FilamentBase<IndirectLight>
    {
        #region Properties

        /// <summary>
        /// <para>Sets the environment's intensity.</para>
        /// <para>Because the environment is encoded usually relative to some reference, the range can be adjusted with
        /// this method.</para>
        /// </summary>
        /// <value>
        /// Scale factor applied to the environment and irradiance such that the result is in cd/m^2 units (default =
        /// 30000)
        /// </value>
        public float Intensity {
            get {
                ThrowExceptionIfDisposed();

                return Native.IndirectLight.GetIntensity(NativePtr);
            }
            set {
                ThrowExceptionIfDisposed();

                Native.IndirectLight.SetIntensity(NativePtr, value);
            }
        }

        /// <summary>
        /// The rigid-body transformation applied to the IBL.
        /// </summary>
        public Matrix3 Rotation {
            set {
                ThrowExceptionIfDisposed();

                Native.IndirectLight.SetRotation(
                    NativePtr,
                    value.M11, value.M12, value.M13,
                    value.M21, value.M22, value.M23,
                    value.M31, value.M32, value.M33
                );
            }
        }

        #endregion

        #region Methods

        private IndirectLight(IntPtr ptr) : base(ptr)
        {
        }

        internal static IndirectLight GetOrCreateCache(IntPtr ptr)
        {
            return GetOrCreateCache(ptr, newPtr => new IndirectLight(newPtr));
        }

        #endregion
    }

    /// <summary>
    /// Used to construct an IndirectLight instance.
    /// </summary>
    public class IndirectLightBuilder : FilamentBase<IndirectLightBuilder>
    {
        #region Methods

        private IndirectLightBuilder(IntPtr ptr) : base(ptr)
        {
        }

        internal static IndirectLightBuilder GetOrCreateCache(IntPtr ptr)
        {
            return GetOrCreateCache(ptr, newPtr => new IndirectLightBuilder(newPtr));
        }

        /// <summary>
        /// Set the reflections cubemap mipmap chain.
        /// </summary>
        /// <param name="cubemap">
        /// A mip-mapped cubemap generated by cmgen. Each cubemap level encodes a the irradiance for a roughness level.
        /// </param>
        /// <returns>This Builder, for chaining calls.</returns>
        public IndirectLightBuilder WithReflections(Texture cubemap)
        {
            ThrowExceptionIfDisposed();

            Native.IndirectLightBuilder.Reflections(NativePtr, cubemap.NativePtr);

            return this;
        }

        /// <summary>
        /// <para>(optional) Environment intensity.</para>
        /// <para>Because the environment is encoded usually relative to some reference, the range can be adjusted with
        /// this method.</para>
        /// </summary>
        /// <param name="envIntensity">
        /// Scale factor applied to the environment and irradiance such that the result is in cd/m^2 (lux) units
        /// (default = 30000)
        /// </param>
        /// <returns>This Builder, for chaining calls.</returns>
        public IndirectLightBuilder WithIntensity(float envIntensity)
        {
            ThrowExceptionIfDisposed();

            Native.IndirectLightBuilder.Intensity(NativePtr, envIntensity);

            return this;
        }

        /// <summary>
        /// <para>Sets the irradiance as Spherical Harmonics.</para>
        /// <para>The irradiance must be pre-convolved by \f$ \langle n \cdot l \rangle \f$ and pre-multiplied by the
        /// Lambertian diffuse BRDF \f$ \frac{1}{\pi} \f$ and specified as Spherical Harmonics coefficients.</para>
        /// <para>Additionally, these Spherical Harmonics coefficients must be pre-scaled by the reconstruction factors
        /// \f$ A_{l}^{m} \f$ below.</para>
        /// <para>The final coefficients can be generated using the `cmgen` tool.</para>
        /// <para>The index in the \p sh array is given by:</para>
        /// <para>`index(l, m) = l * (l + 1) + m`</para>
        /// <para>\f$ sh[index(l,m)] = L_{l}^{m} \frac{1}{\pi} A_{l}^{m} \hat{C_{l}} \f$</para>
        /// <para>index |  l  |  m  |  \f$ A_{l}^{m} \f$ |  \f$ \hat{C_{l}} \f$  |  \f$ \frac{1}{\pi} A_{l}^{m}\hat{C_{l}} \f$ |</para>
        /// <para>:-----:|:---:|:---:|:------------------:|:---------------------:|:--------------------------------------------:</para>
        /// <para>   0   |  0  |  0  |      0.282095      |       3.1415926       |   0.282095</para>
        /// <para>   1   |  1  | -1  |     -0.488602      |       2.0943951       |  -0.325735</para>
        /// <para>   2   |  ^  |  0  |      0.488602      |       ^               |   0.325735</para>
        /// <para>   3   |  ^  |  1  |     -0.488602      |       ^               |  -0.325735</para>
        /// <para>   4   |  2  | -2  |      1.092548      |       0.785398        |   0.273137</para>
        /// <para>   5   |  ^  | -1  |     -1.092548      |       ^               |  -0.273137</para>
        /// <para>   6   |  ^  |  0  |      0.315392      |       ^               |   0.078848</para>
        /// <para>   7   |  ^  |  1  |     -1.092548      |       ^               |  -0.273137</para>
        /// <para>   8   |  ^  |  2  |      0.546274      |       ^               |   0.136569</para>
        /// <para>Note: Because the coefficients are pre-scaled, `sh[0]` is the environment's average irradiance.</para>
        /// </summary>
        /// <param name="bands">Number of spherical harmonics bands. Must be 1, 2 or 3.</param>
        /// <param name="sh">
        /// Array containing the spherical harmonics coefficients. The size of the array must be \f$ bands^{2} \f$.
        /// (i.e. 1, 4 or 9 coefficients respectively).
        /// </param>
        /// <returns>This Builder, for chaining calls.</returns>
        public IndirectLightBuilder WithIrradiance(int bands, Vector3[] sh)
        {
            ThrowExceptionIfDisposed();

            float[] values = new float[sh.Length * 3];

            for (var i = 0; i < sh.Length; i++) {
                values[i * 3] = sh[i].X;
                values[i * 3 + 1] = sh[i].Y;
                values[i * 3 + 2] = sh[i].Z;
            }

            Native.IndirectLightBuilder.Irradiance(NativePtr, bands, values);

            return this;
        }

        /// <summary>
        /// Creates the IndirectLight object.
        /// </summary>
        /// <param name="engine">Reference to the <<see cref="Engine"/> to associate this IndirectLight with.</param>
        /// <returns>The newly created object or nullptr if exceptions are disabled and an error occurred.</returns>
        public IndirectLight Build(Engine engine)
        {
            ThrowExceptionIfDisposed();

            return IndirectLight.GetOrCreateCache(
                Native.IndirectLightBuilder.Build(NativePtr, engine.NativePtr)
            );
        }

        public static IndirectLightBuilder Create()
        {
            return GetOrCreateCache(
                Native.IndirectLightBuilder.Create()
            );
        }

        #endregion
    }
}
